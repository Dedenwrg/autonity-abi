{"events":{"NewRound(uint256,uint256,uint256,uint256)":{"details":"Emitted when a new voting round is started. round - the new round ID height - the height of the current block being executed in the EVM context. timestamp - the TS in time's seconds since Jan 1 1970 (Unix time) that the block been mined by protocol votePeriod - the round period in blocks for the price voting and aggregation."},"NewSymbols(string[],uint256)":{"details":"Emitted when a vote has been succesfully accounted after a {vote} call. round - the round at which new symbols are effective"},"Penalized(address,string,int256,uint120)":{"details":"Emitted when a participant gets penalized as an outlier","params":{"_median":"Median price calculate for this symbol.","_participant":"Oracle address of the validator","_reported":"Reported outlier price.","_symbol":"Outlier symbol."}},"Voted(address,int256[])":{"details":"Emitted when a vote has been succesfully accounted after a {vote} call."}},"kind":"dev","methods":{"constructor":{"details":"Constructor to initialize the Oracle contract.","params":{"_config":"Configuration settings for the oracle.","_symbols":"List of symbols to be tracked.","_voters":"List of initial voters' addresses."}},"finalize()":{"details":"This function has technically infinite gas budget and must not throw in any condition.","returns":{"_0":"true if there is a new round and new symbol prices are available, false if not."}},"getDecimals()":{"details":"IOracle interface method implementation."},"getNewVoters()":{"details":"IOracle interface method implementation."},"getRound()":{"details":"IOracle interface method implementation."},"getRoundData(uint256,string)":{"details":"IOracle interface method","params":{"_round":", the round for which the price should be returned.","_symbol":", the symbol for which the current price should be returned."}},"getVotePeriod()":{"details":"IOracle interface method implementation."},"getVoters()":{"details":"IOracle interface method implementation."},"latestRoundData(string)":{"params":{"_symbol":", the symbol from which the current price should be returned."}},"setOperator(address)":{"details":"IOracle interface method implementation."},"setSymbols(string[])":{"details":"emit {NewSymbols} event.IOracle interface method","params":{"_symbols":"list of string symbols to be used. E.g. \"ATN-USD\""}},"setVotePeriod(uint256)":{"details":"IOracle interface method implementation.."},"setVoters(address[],address[],address[])":{"details":"Only accessible from the Autonity Contract.IOracle interface method implementation."},"updateVoters()":{"details":"Only accessible from the Autonity Contract."},"vote(uint256,(uint120,uint8)[],uint256,uint8)":{"details":"- The function checks that the validator has not already voted in the current round. - If the voter is new (first round), their vote will not be recorded until their next submission. - If the number of reports does not match the expected symbols, the vote will be discarded. - If the last round's commitment does not match the current commitment, the vote is invalidated.","params":{"_commit":"A hash representing the commitment of the new reports.","_extra":"May be used for carrying Autonity Server version. Not used internally.","_reports":"An array of `Report` objects revealing the reports for the previous cycle.","_salt":"The salt value used to generate the last round's commitment."}}},"title":"Autonity Protocol - Oracle Contract","version":1}