{"events":{"Approval(address,address,uint256)":{"details":"Emitted when the allowance of a `spender` for an `owner` is set by a call to {approve}. `value` is the new allowance."},"CallFailed(address,string,bytes)":{"params":{"methodSignature":"method signature of the call, empty in case of plain transaction","returnData":"low level return data","to":"address"}},"MinimumBaseFeeUpdated(uint256)":{"details":"Emitted when the Minimum Gas Price was updated and set to `gasPrice`. Note that `gasPrice` may be zero."},"NewBondingRequest(address,address,bool,uint256)":{"params":{"amount":"The amount of NEWTON to be delegated.","delegator":"The caller.","selfBonded":"True if the validator treasury initiated the request. No LNEW will be issued.","validator":"The validator node account."}},"NewUnbondingRequest(address,address,bool,uint256)":{"params":{"amount":"If self-bonded this is the requested amount of NEWTON to be unbonded. If not self-bonded, this is the amount of Liquid Newton to be unbonded.","delegator":"The caller.","selfBonded":"True if the validator treasury initiated the request.","validator":"The validator node account."}},"Transfer(address,address,uint256)":{"details":"Emitted when `value` tokens are moved from one account (`from`) to another (`to`). Note that `value` may be zero."}},"kind":"dev","methods":{"SetLiquidLogicContract(address)":{"custom:restricted-to":"operator account"},"activateValidator(address)":{"params":{"_address":"address to be enabled."}},"allowance(address,address)":{"details":"See {IERC20-allowance}."},"approve(address,uint256)":{"details":"See {IERC20-approve}. Requirements: - `spender` cannot be the zero address."},"bond(address,uint256)":{"params":{"_amount":"total amount of NTN to bond.","_validator":"address of the validator to delegate stake to."}},"changeCommissionRate(address,uint256)":{"params":{"_validator":"address to be enabled. _rate new commission rate, ranging between 0-10000 (10000 = 100%)."}},"createSchedule(address,uint256,uint256,uint256)":{"custom:restricted-to":"operator account","details":"Locked schedules do not contribute to circulating supply. So minted amount = `_amount` is subtracted from `stakeCirculating`.","params":{"_amount":"total amount of the schedule","_startTime":"start time","_totalDuration":"total duration of the schedule"}},"decimals()":{"details":"ERC-20 Optional.","returns":{"_0":"the number of decimals the NTN token uses."}},"getCommittee()":{"returns":{"_0":"Current block committee if called before finalize(), next block committee if called after."}},"getCommitteeEnodes()":{"returns":{"_0":"Returns the consensus committee enodes."}},"getEpochFromBlock(uint256)":{"params":{"_block":"the input block number."}},"getMaxCommitteeSize()":{"returns":{"_0":"Returns the maximum size of the consensus committee."}},"getMinimumBaseFee()":{"details":"Autonity transaction's gas price must be greater or equal to the minimum gas price.","returns":{"_0":"Returns the minimum gas price."}},"getNewContract()":{"returns":{"_0":"`bytecode` the new contract bytecode.","_1":"`contractAbi` the new contract ABI."}},"getSchedule(address,uint256)":{"params":{"_id":"index of the schedule","_vault":"address of the vault for the schedule"}},"getTotalSchedules(address)":{"params":{"_vault":"address of the vault for the schedules"}},"getValidator(address)":{"returns":{"_0":"Returns the validator object associated with `_addr`."}},"getValidatorState(address)":{"returns":{"_0":"Returns the state of the validator associated with `_addr`."}},"jail(address,uint256,uint8)":{"details":"jails the specified validator","params":{"_jailtime":", the jailing time to be assigned to the validator","_newJailedState":", the validator state to be applied","_nodeAddress":", the node address of the validator to be jailed"},"returns":{"_0":"the block at which the validator will be released from jail"}},"jailbound(address,uint8)":{"details":"jailbounds the specified validator","params":{"_newJailboundState":", the validator state to be applied","_nodeAddress":", the node address of the validator to be jailbound"}},"name()":{"details":"ERC-20 Optional.","returns":{"_0":"the name of the stake token."}},"pauseValidator(address)":{"details":"emit a {DisabledValidator} event.","params":{"_address":"address to be disabled."}},"registerValidator(string,address,bytes,bytes)":{"details":"Emit a {RegisteredValidator} event.","params":{"_consensusKey":"identifying the bls public key in bytes that the validator node is using.","_enode":"enode identifying the validator node.","_oracleAddress":"identifying the oracle server node that the validator is managing.","_signatures":"is a combination of two ecdsa signatures, and a bls signature as the ownership proof of the validator key appended sequentially. The 1st two ecdsa signatures are in below order: 1. a message containing treasury account and signed by validator account private key . 2. a message containing treasury account and signed by Oracle account private key ."}},"setMaxScheduleDuration(uint256)":{"custom:restricted-to":"operator account"},"setMinimumBaseFee(uint256)":{"details":"Emit a {MinimumBaseFeeUpdated} event.","params":{"_price":"Positive integer."}},"setOracleRewardRate(uint256)":{"details":"Can only be called by an operator. Updates `config.policy.oracleRewardRate`.      - The reward rate must not exceed `STANDARD_SCALE_FACTOR` (100%).      - The proposer reward rate plus the oracle reward rate must not exceed 100%","params":{"_oracleRewardRate":"The new reward rate for oracles (scaled by `STANDARD_SCALE_FACTOR`)."}},"setProposerRewardRate(uint256)":{"details":"Can only be called by an operator. Updates `config.policy.proposerRewardRate`.     - The reward rate must not exceed `STANDARD_SCALE_FACTOR` (100%).     - The proposer reward rate plus the oracle reward rate must not exceed 100%","params":{"_proposerRewardRate":"The new reward rate for proposers (scaled by `STANDARD_SCALE_FACTOR`)."}},"setUnbondingPeriod(uint256)":{"details":"Can only be called by an operator. Updates `config.policy.unbondingPeriod`.","params":{"_period":"The new unbonding period, in blocks."}},"setWithheldRewardsPool(address)":{"details":"Can only be called by an operator. Updates `config.policy.withheldRewardsPool`.      The provided address must not be the zero address.","params":{"_pool":"The address of the withheld rewards pool."}},"setWithholdingThreshold(uint256)":{"details":"Can only be called by an operator. Updates `config.policy.withholdingThreshold`.      The threshold must not exceed `STANDARD_SCALE_FACTOR` (100%).","params":{"_withholdingThreshold":"The new withholding threshold (scaled by `STANDARD_SCALE_FACTOR`)."}},"slash(address,uint256)":{"details":"slashes the specified validatorNOTE: 100% slash is not allowed and if attempted will cause a revert","params":{"_nodeAddress":", the node address of the validator to be slashed","_slashingRate":", the rate for the slash"},"returns":{"slashingAmount":", the slashing amount"}},"slashAndJail(address,uint256,uint256,uint8,uint8)":{"details":"slashes and jails the specified validator","params":{"_jailtime":", the jailing time to be assigned to the validator","_newJailboundState":", the validator state to be applied in case of 100% slashing","_newJailedState":", the validator state to be applied for jailing","_nodeAddress":", the node address of the validator to be slashed","_slashingRate":", the rate to be used"},"returns":{"isJailbound":", a flag that signals if the validator has been permanently jailed","jailReleaseBlock":", the block at which the validator will be released from jail","slashingAmount":", the amount slashed in NTN"}},"symbol()":{"details":"ERC-20 Optional.","returns":{"_0":"the Stake token's symbol."}},"transfer(address,uint256)":{"details":"Emits a {Transfer} event. Implementation of {IERC20 transfer}","returns":{"_0":"Returns a boolean value indicating whether the operation succeeded."}},"transferFrom(address,address,uint256)":{"details":"See {IERC20-transferFrom}. Emits an {Approval} event indicating the updated allowance. Requirements: - `sender` and `recipient` must be allowed to hold stake. - `sender` must have a balance of at least `amount`. - the caller must have allowance for ``sender``'s tokens of at least `amount`."},"unbond(address,uint256)":{"params":{"_amount":"total amount of LNTN (or NTN if self delegated) to unbond.","_validator":"address of the validator to unbond stake to."}},"updateEnode(address,string)":{"params":{"_enode":"new enode to be updated","_nodeAddress":"This identifies the validator you want to update"}}},"title":"Proof-of-Stake Autonity Contract ","version":1}