{"events":{"CallFailed(address,string,bytes)":{"notice":"This event is emitted when a call to an address fails in a protocol function (like finalize())."},"NewBondingRequest(address,address,bool,uint256)":{"notice":"This event is emitted when a bonding request to a validator node has been registered. This request will only be effective at the end of the current epoch however the stake will be put in custody immediately from the delegator's account."},"NewUnbondingRequest(address,address,bool,uint256)":{"notice":"This event is emitted when an unbonding request to a validator node has been registered. This request will only be effective after the unbonding period, rounded to the next epoch. Please note that because of potential slashing events during this delay period, the released amount may or may not be correspond to the amount requested."}},"kind":"user","methods":{"SetLiquidLogicContract(address)":{"notice":"Set address of the liquid logic contact."},"activateValidator(address)":{"notice":"Re-activate the specified validator."},"balanceOf(address)":{"notice":"Returns the amount of unbonded Newton token held by the account (ERC-20)."},"bond(address,uint256)":{"notice":"Create a bonding(delegation) request with the caller as delegator. In case the caller is a contract, it needs to send some gas so autonity can notify the caller about staking operations. In case autonity fails to notify the caller (contract), the applied request is reverted."},"burn(address,uint256)":{"notice":"Burn the specified amount of NTN stake token from an account. Restricted to the Operator account. This won't burn associated Liquid tokens."},"changeCommissionRate(address,uint256)":{"notice":"Change commission rate for the specified validator."},"circulatingSupply()":{"notice":"Returns the amount of tokens circulating in the network."},"completeContractUpgrade()":{"notice":"Finalize the contract upgrade. To be called once the storage buffer for the new contract are filled using {upgradeContract} The protocol will then update the bytecode of the autonity contract at block finalization phase."},"computeCommittee()":{"notice":"update the current committee by selecting top staking validators. Restricted to the protocol."},"createSchedule(address,uint256,uint256,uint256)":{"notice":"Creates a new schedule."},"getBlockPeriod()":{"notice":"Returns the block period."},"getCommittee()":{"notice":"Returns the block committee."},"getCurrentEpochPeriod()":{"notice":"Returns the epoch period of the current epoch"},"getEpochByHeight(uint256)":{"notice":"Returns the epoch info of the height."},"getEpochFromBlock(uint256)":{"notice":"Returns epoch associated to the block number."},"getEpochInfo()":{"notice":"Returns the current epoch info of the chain."},"getEpochPeriod()":{"notice":"/**Returns the epoch period. If there will be an update at epoch end, the new epoch period is returned"},"getLastEpochBlock()":{"notice":"Returns the last epoch's end block height."},"getMaxScheduleDuration()":{"notice":"Returns the max allowed duration of any schedule or contract."},"getNewContract()":{"notice":"Getter to retrieve a new Autonity contract bytecode and ABI when an upgrade is initiated."},"getNextEpochBlock()":{"notice":"Returns the next epoch block."},"getOperator()":{"notice":"Returns the current operator account."},"getOracle()":{"notice":"Returns the current Oracle account."},"getSchedule(address,uint256)":{"notice":"Returns the schedule at index = `_id` in the `vaultSchedules[_vault]` array."},"getTotalSchedules(address)":{"notice":"Returns total number of schedules for the vault at address `_vault`."},"getTreasuryAccount()":{"notice":"Returns the current treasury account."},"getTreasuryFee()":{"notice":"Returns the current treasury fee."},"getUnbondingPeriod()":{"notice":"Returns the un-bonding period."},"getValidators()":{"notice":"Returns the current list of validators."},"getVersion()":{"notice":"Returns the current contract version."},"isUnbondingReleased(uint256)":{"notice":"Returns `true` if unbonding is released and `false` otherwise."},"liquidLogicContract()":{"notice":"Address of the `LiquidLogic` contract. This contract contains all the logic for liquid newton related operations. The state variables are stored in `LiquidState` contract which is different for every validator and is deployed when registering a new validator. To do any operation related to liquid newton, we call `LiquidState` contract of the related validator and that contract does a delegate call to `LiquidLogic` contract."},"pauseValidator(address)":{"notice":"Pause the validator and stop it accepting delegations."},"registerValidator(string,address,bytes,bytes)":{"notice":"Register a new validator in the system.  The validator might be selected to be part of consensus. This validator will have assigned to its treasury account the caller of this function. A new token \"Liquid Stake\" is deployed at this phase."},"resetContractUpgrade()":{"notice":"Reset internal storage contract-upgrade buffers in case of issue."},"setMaxScheduleDuration(uint256)":{"notice":"Sets the max allowed duration of any schedule or contract."},"setMinimumBaseFee(uint256)":{"notice":"Set the minimum gas price. Restricted to the operator account."},"setOracleRewardRate(uint256)":{"notice":"Sets the oracle reward rate for the policy configuration."},"setProposerRewardRate(uint256)":{"notice":"Sets the proposer reward rate for the policy configuration."},"setUnbondingPeriod(uint256)":{"notice":"Sets the unbonding period for the policy configuration."},"setWithheldRewardsPool(address)":{"notice":"Sets the address of the pool to which withheld rewards will be sent."},"setWithholdingThreshold(uint256)":{"notice":"Sets the withholding threshold for the policy configuration."},"totalSupply()":{"notice":"Returns the total amount of stake token issued."},"transfer(address,uint256)":{"notice":"Moves `amount` NTN stake tokens from the caller's account to `recipient`."},"unbond(address,uint256)":{"notice":"Create an unbonding request with the caller as delegator. In case the caller is a contract, it needs to send some gas so autonity can notify the caller about staking operations. In case autonity fails to notify the caller (contract), the applied request is reverted."},"updateEnode(address,string)":{"notice":"Update enode of a registered validator. This function updates the network connection information (IP or/and port) of a registered validator. you cannot change the validator's address (pubkey part of the enode)"},"upgradeContract(bytes,string)":{"notice":"Append to the contract storage buffer the new contract bytecode and abi. Should be called as many times as required."}},"version":1}